// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/iWorld-y/domain_radar/ent/actionguide"
	"github.com/iWorld-y/domain_radar/ent/article"
	"github.com/iWorld-y/domain_radar/ent/deepanalysisresult"
	"github.com/iWorld-y/domain_radar/ent/domainreport"
	"github.com/iWorld-y/domain_radar/ent/keyevent"
	"github.com/iWorld-y/domain_radar/ent/predicate"
	"github.com/iWorld-y/domain_radar/ent/reportrun"
	"github.com/iWorld-y/domain_radar/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActionGuide        = "ActionGuide"
	TypeArticle            = "Article"
	TypeDeepAnalysisResult = "DeepAnalysisResult"
	TypeDomainReport       = "DomainReport"
	TypeKeyEvent           = "KeyEvent"
	TypeReportRun          = "ReportRun"
	TypeUser               = "User"
)

// ActionGuideMutation represents an operation that mutates the ActionGuide nodes in the graph.
type ActionGuideMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	guide_content               *string
	clearedFields               map[string]struct{}
	deep_analysis_result        *int
	cleareddeep_analysis_result bool
	done                        bool
	oldValue                    func(context.Context) (*ActionGuide, error)
	predicates                  []predicate.ActionGuide
}

var _ ent.Mutation = (*ActionGuideMutation)(nil)

// actionguideOption allows management of the mutation configuration using functional options.
type actionguideOption func(*ActionGuideMutation)

// newActionGuideMutation creates new mutation for the ActionGuide entity.
func newActionGuideMutation(c config, op Op, opts ...actionguideOption) *ActionGuideMutation {
	m := &ActionGuideMutation{
		config:        c,
		op:            op,
		typ:           TypeActionGuide,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionGuideID sets the ID field of the mutation.
func withActionGuideID(id int) actionguideOption {
	return func(m *ActionGuideMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionGuide
		)
		m.oldValue = func(ctx context.Context) (*ActionGuide, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionGuide.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionGuide sets the old ActionGuide of the mutation.
func withActionGuide(node *ActionGuide) actionguideOption {
	return func(m *ActionGuideMutation) {
		m.oldValue = func(context.Context) (*ActionGuide, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionGuideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionGuideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionGuide entities.
func (m *ActionGuideMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionGuideMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionGuideMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionGuide.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeepAnalysisID sets the "deep_analysis_id" field.
func (m *ActionGuideMutation) SetDeepAnalysisID(i int) {
	m.deep_analysis_result = &i
}

// DeepAnalysisID returns the value of the "deep_analysis_id" field in the mutation.
func (m *ActionGuideMutation) DeepAnalysisID() (r int, exists bool) {
	v := m.deep_analysis_result
	if v == nil {
		return
	}
	return *v, true
}

// OldDeepAnalysisID returns the old "deep_analysis_id" field's value of the ActionGuide entity.
// If the ActionGuide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionGuideMutation) OldDeepAnalysisID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeepAnalysisID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeepAnalysisID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeepAnalysisID: %w", err)
	}
	return oldValue.DeepAnalysisID, nil
}

// ClearDeepAnalysisID clears the value of the "deep_analysis_id" field.
func (m *ActionGuideMutation) ClearDeepAnalysisID() {
	m.deep_analysis_result = nil
	m.clearedFields[actionguide.FieldDeepAnalysisID] = struct{}{}
}

// DeepAnalysisIDCleared returns if the "deep_analysis_id" field was cleared in this mutation.
func (m *ActionGuideMutation) DeepAnalysisIDCleared() bool {
	_, ok := m.clearedFields[actionguide.FieldDeepAnalysisID]
	return ok
}

// ResetDeepAnalysisID resets all changes to the "deep_analysis_id" field.
func (m *ActionGuideMutation) ResetDeepAnalysisID() {
	m.deep_analysis_result = nil
	delete(m.clearedFields, actionguide.FieldDeepAnalysisID)
}

// SetGuideContent sets the "guide_content" field.
func (m *ActionGuideMutation) SetGuideContent(s string) {
	m.guide_content = &s
}

// GuideContent returns the value of the "guide_content" field in the mutation.
func (m *ActionGuideMutation) GuideContent() (r string, exists bool) {
	v := m.guide_content
	if v == nil {
		return
	}
	return *v, true
}

// OldGuideContent returns the old "guide_content" field's value of the ActionGuide entity.
// If the ActionGuide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionGuideMutation) OldGuideContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuideContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuideContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuideContent: %w", err)
	}
	return oldValue.GuideContent, nil
}

// ClearGuideContent clears the value of the "guide_content" field.
func (m *ActionGuideMutation) ClearGuideContent() {
	m.guide_content = nil
	m.clearedFields[actionguide.FieldGuideContent] = struct{}{}
}

// GuideContentCleared returns if the "guide_content" field was cleared in this mutation.
func (m *ActionGuideMutation) GuideContentCleared() bool {
	_, ok := m.clearedFields[actionguide.FieldGuideContent]
	return ok
}

// ResetGuideContent resets all changes to the "guide_content" field.
func (m *ActionGuideMutation) ResetGuideContent() {
	m.guide_content = nil
	delete(m.clearedFields, actionguide.FieldGuideContent)
}

// SetDeepAnalysisResultID sets the "deep_analysis_result" edge to the DeepAnalysisResult entity by id.
func (m *ActionGuideMutation) SetDeepAnalysisResultID(id int) {
	m.deep_analysis_result = &id
}

// ClearDeepAnalysisResult clears the "deep_analysis_result" edge to the DeepAnalysisResult entity.
func (m *ActionGuideMutation) ClearDeepAnalysisResult() {
	m.cleareddeep_analysis_result = true
	m.clearedFields[actionguide.FieldDeepAnalysisID] = struct{}{}
}

// DeepAnalysisResultCleared reports if the "deep_analysis_result" edge to the DeepAnalysisResult entity was cleared.
func (m *ActionGuideMutation) DeepAnalysisResultCleared() bool {
	return m.DeepAnalysisIDCleared() || m.cleareddeep_analysis_result
}

// DeepAnalysisResultID returns the "deep_analysis_result" edge ID in the mutation.
func (m *ActionGuideMutation) DeepAnalysisResultID() (id int, exists bool) {
	if m.deep_analysis_result != nil {
		return *m.deep_analysis_result, true
	}
	return
}

// DeepAnalysisResultIDs returns the "deep_analysis_result" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeepAnalysisResultID instead. It exists only for internal usage by the builders.
func (m *ActionGuideMutation) DeepAnalysisResultIDs() (ids []int) {
	if id := m.deep_analysis_result; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeepAnalysisResult resets all changes to the "deep_analysis_result" edge.
func (m *ActionGuideMutation) ResetDeepAnalysisResult() {
	m.deep_analysis_result = nil
	m.cleareddeep_analysis_result = false
}

// Where appends a list predicates to the ActionGuideMutation builder.
func (m *ActionGuideMutation) Where(ps ...predicate.ActionGuide) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionGuideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionGuideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionGuide, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionGuideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionGuideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionGuide).
func (m *ActionGuideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionGuideMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.deep_analysis_result != nil {
		fields = append(fields, actionguide.FieldDeepAnalysisID)
	}
	if m.guide_content != nil {
		fields = append(fields, actionguide.FieldGuideContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionGuideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionguide.FieldDeepAnalysisID:
		return m.DeepAnalysisID()
	case actionguide.FieldGuideContent:
		return m.GuideContent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionGuideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionguide.FieldDeepAnalysisID:
		return m.OldDeepAnalysisID(ctx)
	case actionguide.FieldGuideContent:
		return m.OldGuideContent(ctx)
	}
	return nil, fmt.Errorf("unknown ActionGuide field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionGuideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionguide.FieldDeepAnalysisID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeepAnalysisID(v)
		return nil
	case actionguide.FieldGuideContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuideContent(v)
		return nil
	}
	return fmt.Errorf("unknown ActionGuide field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionGuideMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionGuideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionGuideMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionGuide numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionGuideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionguide.FieldDeepAnalysisID) {
		fields = append(fields, actionguide.FieldDeepAnalysisID)
	}
	if m.FieldCleared(actionguide.FieldGuideContent) {
		fields = append(fields, actionguide.FieldGuideContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionGuideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionGuideMutation) ClearField(name string) error {
	switch name {
	case actionguide.FieldDeepAnalysisID:
		m.ClearDeepAnalysisID()
		return nil
	case actionguide.FieldGuideContent:
		m.ClearGuideContent()
		return nil
	}
	return fmt.Errorf("unknown ActionGuide nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionGuideMutation) ResetField(name string) error {
	switch name {
	case actionguide.FieldDeepAnalysisID:
		m.ResetDeepAnalysisID()
		return nil
	case actionguide.FieldGuideContent:
		m.ResetGuideContent()
		return nil
	}
	return fmt.Errorf("unknown ActionGuide field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionGuideMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deep_analysis_result != nil {
		edges = append(edges, actionguide.EdgeDeepAnalysisResult)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionGuideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actionguide.EdgeDeepAnalysisResult:
		if id := m.deep_analysis_result; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionGuideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionGuideMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionGuideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeep_analysis_result {
		edges = append(edges, actionguide.EdgeDeepAnalysisResult)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionGuideMutation) EdgeCleared(name string) bool {
	switch name {
	case actionguide.EdgeDeepAnalysisResult:
		return m.cleareddeep_analysis_result
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionGuideMutation) ClearEdge(name string) error {
	switch name {
	case actionguide.EdgeDeepAnalysisResult:
		m.ClearDeepAnalysisResult()
		return nil
	}
	return fmt.Errorf("unknown ActionGuide unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionGuideMutation) ResetEdge(name string) error {
	switch name {
	case actionguide.EdgeDeepAnalysisResult:
		m.ResetDeepAnalysisResult()
		return nil
	}
	return fmt.Errorf("unknown ActionGuide edge %s", name)
}

// ArticleMutation represents an operation that mutates the Article nodes in the graph.
type ArticleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	title                *string
	link                 *string
	source               *string
	pub_date             *string
	content              *string
	clearedFields        map[string]struct{}
	domain_report        *int
	cleareddomain_report bool
	done                 bool
	oldValue             func(context.Context) (*Article, error)
	predicates           []predicate.Article
}

var _ ent.Mutation = (*ArticleMutation)(nil)

// articleOption allows management of the mutation configuration using functional options.
type articleOption func(*ArticleMutation)

// newArticleMutation creates new mutation for the Article entity.
func newArticleMutation(c config, op Op, opts ...articleOption) *ArticleMutation {
	m := &ArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArticleID sets the ID field of the mutation.
func withArticleID(id int) articleOption {
	return func(m *ArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *Article
		)
		m.oldValue = func(ctx context.Context) (*Article, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Article.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArticle sets the old Article of the mutation.
func withArticle(node *Article) articleOption {
	return func(m *ArticleMutation) {
		m.oldValue = func(context.Context) (*Article, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Article entities.
func (m *ArticleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArticleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArticleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Article.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDomainReportID sets the "domain_report_id" field.
func (m *ArticleMutation) SetDomainReportID(i int) {
	m.domain_report = &i
}

// DomainReportID returns the value of the "domain_report_id" field in the mutation.
func (m *ArticleMutation) DomainReportID() (r int, exists bool) {
	v := m.domain_report
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainReportID returns the old "domain_report_id" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldDomainReportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainReportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainReportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainReportID: %w", err)
	}
	return oldValue.DomainReportID, nil
}

// ClearDomainReportID clears the value of the "domain_report_id" field.
func (m *ArticleMutation) ClearDomainReportID() {
	m.domain_report = nil
	m.clearedFields[article.FieldDomainReportID] = struct{}{}
}

// DomainReportIDCleared returns if the "domain_report_id" field was cleared in this mutation.
func (m *ArticleMutation) DomainReportIDCleared() bool {
	_, ok := m.clearedFields[article.FieldDomainReportID]
	return ok
}

// ResetDomainReportID resets all changes to the "domain_report_id" field.
func (m *ArticleMutation) ResetDomainReportID() {
	m.domain_report = nil
	delete(m.clearedFields, article.FieldDomainReportID)
}

// SetTitle sets the "title" field.
func (m *ArticleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ArticleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ArticleMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[article.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ArticleMutation) TitleCleared() bool {
	_, ok := m.clearedFields[article.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ArticleMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, article.FieldTitle)
}

// SetLink sets the "link" field.
func (m *ArticleMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *ArticleMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *ArticleMutation) ClearLink() {
	m.link = nil
	m.clearedFields[article.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *ArticleMutation) LinkCleared() bool {
	_, ok := m.clearedFields[article.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *ArticleMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, article.FieldLink)
}

// SetSource sets the "source" field.
func (m *ArticleMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ArticleMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ArticleMutation) ClearSource() {
	m.source = nil
	m.clearedFields[article.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ArticleMutation) SourceCleared() bool {
	_, ok := m.clearedFields[article.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ArticleMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, article.FieldSource)
}

// SetPubDate sets the "pub_date" field.
func (m *ArticleMutation) SetPubDate(s string) {
	m.pub_date = &s
}

// PubDate returns the value of the "pub_date" field in the mutation.
func (m *ArticleMutation) PubDate() (r string, exists bool) {
	v := m.pub_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPubDate returns the old "pub_date" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldPubDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPubDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPubDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPubDate: %w", err)
	}
	return oldValue.PubDate, nil
}

// ClearPubDate clears the value of the "pub_date" field.
func (m *ArticleMutation) ClearPubDate() {
	m.pub_date = nil
	m.clearedFields[article.FieldPubDate] = struct{}{}
}

// PubDateCleared returns if the "pub_date" field was cleared in this mutation.
func (m *ArticleMutation) PubDateCleared() bool {
	_, ok := m.clearedFields[article.FieldPubDate]
	return ok
}

// ResetPubDate resets all changes to the "pub_date" field.
func (m *ArticleMutation) ResetPubDate() {
	m.pub_date = nil
	delete(m.clearedFields, article.FieldPubDate)
}

// SetContent sets the "content" field.
func (m *ArticleMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ArticleMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Article entity.
// If the Article object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArticleMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ArticleMutation) ClearContent() {
	m.content = nil
	m.clearedFields[article.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ArticleMutation) ContentCleared() bool {
	_, ok := m.clearedFields[article.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ArticleMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, article.FieldContent)
}

// ClearDomainReport clears the "domain_report" edge to the DomainReport entity.
func (m *ArticleMutation) ClearDomainReport() {
	m.cleareddomain_report = true
	m.clearedFields[article.FieldDomainReportID] = struct{}{}
}

// DomainReportCleared reports if the "domain_report" edge to the DomainReport entity was cleared.
func (m *ArticleMutation) DomainReportCleared() bool {
	return m.DomainReportIDCleared() || m.cleareddomain_report
}

// DomainReportIDs returns the "domain_report" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainReportID instead. It exists only for internal usage by the builders.
func (m *ArticleMutation) DomainReportIDs() (ids []int) {
	if id := m.domain_report; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomainReport resets all changes to the "domain_report" edge.
func (m *ArticleMutation) ResetDomainReport() {
	m.domain_report = nil
	m.cleareddomain_report = false
}

// Where appends a list predicates to the ArticleMutation builder.
func (m *ArticleMutation) Where(ps ...predicate.Article) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Article, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Article).
func (m *ArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArticleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.domain_report != nil {
		fields = append(fields, article.FieldDomainReportID)
	}
	if m.title != nil {
		fields = append(fields, article.FieldTitle)
	}
	if m.link != nil {
		fields = append(fields, article.FieldLink)
	}
	if m.source != nil {
		fields = append(fields, article.FieldSource)
	}
	if m.pub_date != nil {
		fields = append(fields, article.FieldPubDate)
	}
	if m.content != nil {
		fields = append(fields, article.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case article.FieldDomainReportID:
		return m.DomainReportID()
	case article.FieldTitle:
		return m.Title()
	case article.FieldLink:
		return m.Link()
	case article.FieldSource:
		return m.Source()
	case article.FieldPubDate:
		return m.PubDate()
	case article.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case article.FieldDomainReportID:
		return m.OldDomainReportID(ctx)
	case article.FieldTitle:
		return m.OldTitle(ctx)
	case article.FieldLink:
		return m.OldLink(ctx)
	case article.FieldSource:
		return m.OldSource(ctx)
	case article.FieldPubDate:
		return m.OldPubDate(ctx)
	case article.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Article field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case article.FieldDomainReportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainReportID(v)
		return nil
	case article.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case article.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case article.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case article.FieldPubDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPubDate(v)
		return nil
	case article.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArticleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArticleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Article numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(article.FieldDomainReportID) {
		fields = append(fields, article.FieldDomainReportID)
	}
	if m.FieldCleared(article.FieldTitle) {
		fields = append(fields, article.FieldTitle)
	}
	if m.FieldCleared(article.FieldLink) {
		fields = append(fields, article.FieldLink)
	}
	if m.FieldCleared(article.FieldSource) {
		fields = append(fields, article.FieldSource)
	}
	if m.FieldCleared(article.FieldPubDate) {
		fields = append(fields, article.FieldPubDate)
	}
	if m.FieldCleared(article.FieldContent) {
		fields = append(fields, article.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArticleMutation) ClearField(name string) error {
	switch name {
	case article.FieldDomainReportID:
		m.ClearDomainReportID()
		return nil
	case article.FieldTitle:
		m.ClearTitle()
		return nil
	case article.FieldLink:
		m.ClearLink()
		return nil
	case article.FieldSource:
		m.ClearSource()
		return nil
	case article.FieldPubDate:
		m.ClearPubDate()
		return nil
	case article.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Article nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArticleMutation) ResetField(name string) error {
	switch name {
	case article.FieldDomainReportID:
		m.ResetDomainReportID()
		return nil
	case article.FieldTitle:
		m.ResetTitle()
		return nil
	case article.FieldLink:
		m.ResetLink()
		return nil
	case article.FieldSource:
		m.ResetSource()
		return nil
	case article.FieldPubDate:
		m.ResetPubDate()
		return nil
	case article.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Article field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.domain_report != nil {
		edges = append(edges, article.EdgeDomainReport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArticleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case article.EdgeDomainReport:
		if id := m.domain_report; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArticleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddomain_report {
		edges = append(edges, article.EdgeDomainReport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArticleMutation) EdgeCleared(name string) bool {
	switch name {
	case article.EdgeDomainReport:
		return m.cleareddomain_report
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArticleMutation) ClearEdge(name string) error {
	switch name {
	case article.EdgeDomainReport:
		m.ClearDomainReport()
		return nil
	}
	return fmt.Errorf("unknown Article unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArticleMutation) ResetEdge(name string) error {
	switch name {
	case article.EdgeDomainReport:
		m.ResetDomainReport()
		return nil
	}
	return fmt.Errorf("unknown Article edge %s", name)
}

// DeepAnalysisResultMutation represents an operation that mutates the DeepAnalysisResult nodes in the graph.
type DeepAnalysisResultMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	macro_trends         *string
	opportunities        *string
	risks                *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	report_run           *int
	clearedreport_run    bool
	action_guides        map[int]struct{}
	removedaction_guides map[int]struct{}
	clearedaction_guides bool
	done                 bool
	oldValue             func(context.Context) (*DeepAnalysisResult, error)
	predicates           []predicate.DeepAnalysisResult
}

var _ ent.Mutation = (*DeepAnalysisResultMutation)(nil)

// deepanalysisresultOption allows management of the mutation configuration using functional options.
type deepanalysisresultOption func(*DeepAnalysisResultMutation)

// newDeepAnalysisResultMutation creates new mutation for the DeepAnalysisResult entity.
func newDeepAnalysisResultMutation(c config, op Op, opts ...deepanalysisresultOption) *DeepAnalysisResultMutation {
	m := &DeepAnalysisResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDeepAnalysisResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeepAnalysisResultID sets the ID field of the mutation.
func withDeepAnalysisResultID(id int) deepanalysisresultOption {
	return func(m *DeepAnalysisResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DeepAnalysisResult
		)
		m.oldValue = func(ctx context.Context) (*DeepAnalysisResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeepAnalysisResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeepAnalysisResult sets the old DeepAnalysisResult of the mutation.
func withDeepAnalysisResult(node *DeepAnalysisResult) deepanalysisresultOption {
	return func(m *DeepAnalysisResultMutation) {
		m.oldValue = func(context.Context) (*DeepAnalysisResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeepAnalysisResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeepAnalysisResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeepAnalysisResult entities.
func (m *DeepAnalysisResultMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeepAnalysisResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeepAnalysisResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeepAnalysisResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *DeepAnalysisResultMutation) SetRunID(i int) {
	m.report_run = &i
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *DeepAnalysisResultMutation) RunID() (r int, exists bool) {
	v := m.report_run
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the DeepAnalysisResult entity.
// If the DeepAnalysisResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeepAnalysisResultMutation) OldRunID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ClearRunID clears the value of the "run_id" field.
func (m *DeepAnalysisResultMutation) ClearRunID() {
	m.report_run = nil
	m.clearedFields[deepanalysisresult.FieldRunID] = struct{}{}
}

// RunIDCleared returns if the "run_id" field was cleared in this mutation.
func (m *DeepAnalysisResultMutation) RunIDCleared() bool {
	_, ok := m.clearedFields[deepanalysisresult.FieldRunID]
	return ok
}

// ResetRunID resets all changes to the "run_id" field.
func (m *DeepAnalysisResultMutation) ResetRunID() {
	m.report_run = nil
	delete(m.clearedFields, deepanalysisresult.FieldRunID)
}

// SetMacroTrends sets the "macro_trends" field.
func (m *DeepAnalysisResultMutation) SetMacroTrends(s string) {
	m.macro_trends = &s
}

// MacroTrends returns the value of the "macro_trends" field in the mutation.
func (m *DeepAnalysisResultMutation) MacroTrends() (r string, exists bool) {
	v := m.macro_trends
	if v == nil {
		return
	}
	return *v, true
}

// OldMacroTrends returns the old "macro_trends" field's value of the DeepAnalysisResult entity.
// If the DeepAnalysisResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeepAnalysisResultMutation) OldMacroTrends(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMacroTrends is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMacroTrends requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMacroTrends: %w", err)
	}
	return oldValue.MacroTrends, nil
}

// ClearMacroTrends clears the value of the "macro_trends" field.
func (m *DeepAnalysisResultMutation) ClearMacroTrends() {
	m.macro_trends = nil
	m.clearedFields[deepanalysisresult.FieldMacroTrends] = struct{}{}
}

// MacroTrendsCleared returns if the "macro_trends" field was cleared in this mutation.
func (m *DeepAnalysisResultMutation) MacroTrendsCleared() bool {
	_, ok := m.clearedFields[deepanalysisresult.FieldMacroTrends]
	return ok
}

// ResetMacroTrends resets all changes to the "macro_trends" field.
func (m *DeepAnalysisResultMutation) ResetMacroTrends() {
	m.macro_trends = nil
	delete(m.clearedFields, deepanalysisresult.FieldMacroTrends)
}

// SetOpportunities sets the "opportunities" field.
func (m *DeepAnalysisResultMutation) SetOpportunities(s string) {
	m.opportunities = &s
}

// Opportunities returns the value of the "opportunities" field in the mutation.
func (m *DeepAnalysisResultMutation) Opportunities() (r string, exists bool) {
	v := m.opportunities
	if v == nil {
		return
	}
	return *v, true
}

// OldOpportunities returns the old "opportunities" field's value of the DeepAnalysisResult entity.
// If the DeepAnalysisResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeepAnalysisResultMutation) OldOpportunities(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpportunities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpportunities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpportunities: %w", err)
	}
	return oldValue.Opportunities, nil
}

// ClearOpportunities clears the value of the "opportunities" field.
func (m *DeepAnalysisResultMutation) ClearOpportunities() {
	m.opportunities = nil
	m.clearedFields[deepanalysisresult.FieldOpportunities] = struct{}{}
}

// OpportunitiesCleared returns if the "opportunities" field was cleared in this mutation.
func (m *DeepAnalysisResultMutation) OpportunitiesCleared() bool {
	_, ok := m.clearedFields[deepanalysisresult.FieldOpportunities]
	return ok
}

// ResetOpportunities resets all changes to the "opportunities" field.
func (m *DeepAnalysisResultMutation) ResetOpportunities() {
	m.opportunities = nil
	delete(m.clearedFields, deepanalysisresult.FieldOpportunities)
}

// SetRisks sets the "risks" field.
func (m *DeepAnalysisResultMutation) SetRisks(s string) {
	m.risks = &s
}

// Risks returns the value of the "risks" field in the mutation.
func (m *DeepAnalysisResultMutation) Risks() (r string, exists bool) {
	v := m.risks
	if v == nil {
		return
	}
	return *v, true
}

// OldRisks returns the old "risks" field's value of the DeepAnalysisResult entity.
// If the DeepAnalysisResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeepAnalysisResultMutation) OldRisks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRisks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRisks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRisks: %w", err)
	}
	return oldValue.Risks, nil
}

// ClearRisks clears the value of the "risks" field.
func (m *DeepAnalysisResultMutation) ClearRisks() {
	m.risks = nil
	m.clearedFields[deepanalysisresult.FieldRisks] = struct{}{}
}

// RisksCleared returns if the "risks" field was cleared in this mutation.
func (m *DeepAnalysisResultMutation) RisksCleared() bool {
	_, ok := m.clearedFields[deepanalysisresult.FieldRisks]
	return ok
}

// ResetRisks resets all changes to the "risks" field.
func (m *DeepAnalysisResultMutation) ResetRisks() {
	m.risks = nil
	delete(m.clearedFields, deepanalysisresult.FieldRisks)
}

// SetCreatedAt sets the "created_at" field.
func (m *DeepAnalysisResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeepAnalysisResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeepAnalysisResult entity.
// If the DeepAnalysisResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeepAnalysisResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeepAnalysisResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReportRunID sets the "report_run" edge to the ReportRun entity by id.
func (m *DeepAnalysisResultMutation) SetReportRunID(id int) {
	m.report_run = &id
}

// ClearReportRun clears the "report_run" edge to the ReportRun entity.
func (m *DeepAnalysisResultMutation) ClearReportRun() {
	m.clearedreport_run = true
	m.clearedFields[deepanalysisresult.FieldRunID] = struct{}{}
}

// ReportRunCleared reports if the "report_run" edge to the ReportRun entity was cleared.
func (m *DeepAnalysisResultMutation) ReportRunCleared() bool {
	return m.RunIDCleared() || m.clearedreport_run
}

// ReportRunID returns the "report_run" edge ID in the mutation.
func (m *DeepAnalysisResultMutation) ReportRunID() (id int, exists bool) {
	if m.report_run != nil {
		return *m.report_run, true
	}
	return
}

// ReportRunIDs returns the "report_run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportRunID instead. It exists only for internal usage by the builders.
func (m *DeepAnalysisResultMutation) ReportRunIDs() (ids []int) {
	if id := m.report_run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportRun resets all changes to the "report_run" edge.
func (m *DeepAnalysisResultMutation) ResetReportRun() {
	m.report_run = nil
	m.clearedreport_run = false
}

// AddActionGuideIDs adds the "action_guides" edge to the ActionGuide entity by ids.
func (m *DeepAnalysisResultMutation) AddActionGuideIDs(ids ...int) {
	if m.action_guides == nil {
		m.action_guides = make(map[int]struct{})
	}
	for i := range ids {
		m.action_guides[ids[i]] = struct{}{}
	}
}

// ClearActionGuides clears the "action_guides" edge to the ActionGuide entity.
func (m *DeepAnalysisResultMutation) ClearActionGuides() {
	m.clearedaction_guides = true
}

// ActionGuidesCleared reports if the "action_guides" edge to the ActionGuide entity was cleared.
func (m *DeepAnalysisResultMutation) ActionGuidesCleared() bool {
	return m.clearedaction_guides
}

// RemoveActionGuideIDs removes the "action_guides" edge to the ActionGuide entity by IDs.
func (m *DeepAnalysisResultMutation) RemoveActionGuideIDs(ids ...int) {
	if m.removedaction_guides == nil {
		m.removedaction_guides = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.action_guides, ids[i])
		m.removedaction_guides[ids[i]] = struct{}{}
	}
}

// RemovedActionGuides returns the removed IDs of the "action_guides" edge to the ActionGuide entity.
func (m *DeepAnalysisResultMutation) RemovedActionGuidesIDs() (ids []int) {
	for id := range m.removedaction_guides {
		ids = append(ids, id)
	}
	return
}

// ActionGuidesIDs returns the "action_guides" edge IDs in the mutation.
func (m *DeepAnalysisResultMutation) ActionGuidesIDs() (ids []int) {
	for id := range m.action_guides {
		ids = append(ids, id)
	}
	return
}

// ResetActionGuides resets all changes to the "action_guides" edge.
func (m *DeepAnalysisResultMutation) ResetActionGuides() {
	m.action_guides = nil
	m.clearedaction_guides = false
	m.removedaction_guides = nil
}

// Where appends a list predicates to the DeepAnalysisResultMutation builder.
func (m *DeepAnalysisResultMutation) Where(ps ...predicate.DeepAnalysisResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeepAnalysisResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeepAnalysisResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeepAnalysisResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeepAnalysisResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeepAnalysisResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeepAnalysisResult).
func (m *DeepAnalysisResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeepAnalysisResultMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.report_run != nil {
		fields = append(fields, deepanalysisresult.FieldRunID)
	}
	if m.macro_trends != nil {
		fields = append(fields, deepanalysisresult.FieldMacroTrends)
	}
	if m.opportunities != nil {
		fields = append(fields, deepanalysisresult.FieldOpportunities)
	}
	if m.risks != nil {
		fields = append(fields, deepanalysisresult.FieldRisks)
	}
	if m.created_at != nil {
		fields = append(fields, deepanalysisresult.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeepAnalysisResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deepanalysisresult.FieldRunID:
		return m.RunID()
	case deepanalysisresult.FieldMacroTrends:
		return m.MacroTrends()
	case deepanalysisresult.FieldOpportunities:
		return m.Opportunities()
	case deepanalysisresult.FieldRisks:
		return m.Risks()
	case deepanalysisresult.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeepAnalysisResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deepanalysisresult.FieldRunID:
		return m.OldRunID(ctx)
	case deepanalysisresult.FieldMacroTrends:
		return m.OldMacroTrends(ctx)
	case deepanalysisresult.FieldOpportunities:
		return m.OldOpportunities(ctx)
	case deepanalysisresult.FieldRisks:
		return m.OldRisks(ctx)
	case deepanalysisresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeepAnalysisResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeepAnalysisResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deepanalysisresult.FieldRunID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case deepanalysisresult.FieldMacroTrends:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMacroTrends(v)
		return nil
	case deepanalysisresult.FieldOpportunities:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpportunities(v)
		return nil
	case deepanalysisresult.FieldRisks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRisks(v)
		return nil
	case deepanalysisresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeepAnalysisResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeepAnalysisResultMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeepAnalysisResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeepAnalysisResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeepAnalysisResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeepAnalysisResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deepanalysisresult.FieldRunID) {
		fields = append(fields, deepanalysisresult.FieldRunID)
	}
	if m.FieldCleared(deepanalysisresult.FieldMacroTrends) {
		fields = append(fields, deepanalysisresult.FieldMacroTrends)
	}
	if m.FieldCleared(deepanalysisresult.FieldOpportunities) {
		fields = append(fields, deepanalysisresult.FieldOpportunities)
	}
	if m.FieldCleared(deepanalysisresult.FieldRisks) {
		fields = append(fields, deepanalysisresult.FieldRisks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeepAnalysisResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeepAnalysisResultMutation) ClearField(name string) error {
	switch name {
	case deepanalysisresult.FieldRunID:
		m.ClearRunID()
		return nil
	case deepanalysisresult.FieldMacroTrends:
		m.ClearMacroTrends()
		return nil
	case deepanalysisresult.FieldOpportunities:
		m.ClearOpportunities()
		return nil
	case deepanalysisresult.FieldRisks:
		m.ClearRisks()
		return nil
	}
	return fmt.Errorf("unknown DeepAnalysisResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeepAnalysisResultMutation) ResetField(name string) error {
	switch name {
	case deepanalysisresult.FieldRunID:
		m.ResetRunID()
		return nil
	case deepanalysisresult.FieldMacroTrends:
		m.ResetMacroTrends()
		return nil
	case deepanalysisresult.FieldOpportunities:
		m.ResetOpportunities()
		return nil
	case deepanalysisresult.FieldRisks:
		m.ResetRisks()
		return nil
	case deepanalysisresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeepAnalysisResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeepAnalysisResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.report_run != nil {
		edges = append(edges, deepanalysisresult.EdgeReportRun)
	}
	if m.action_guides != nil {
		edges = append(edges, deepanalysisresult.EdgeActionGuides)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeepAnalysisResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deepanalysisresult.EdgeReportRun:
		if id := m.report_run; id != nil {
			return []ent.Value{*id}
		}
	case deepanalysisresult.EdgeActionGuides:
		ids := make([]ent.Value, 0, len(m.action_guides))
		for id := range m.action_guides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeepAnalysisResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaction_guides != nil {
		edges = append(edges, deepanalysisresult.EdgeActionGuides)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeepAnalysisResultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deepanalysisresult.EdgeActionGuides:
		ids := make([]ent.Value, 0, len(m.removedaction_guides))
		for id := range m.removedaction_guides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeepAnalysisResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreport_run {
		edges = append(edges, deepanalysisresult.EdgeReportRun)
	}
	if m.clearedaction_guides {
		edges = append(edges, deepanalysisresult.EdgeActionGuides)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeepAnalysisResultMutation) EdgeCleared(name string) bool {
	switch name {
	case deepanalysisresult.EdgeReportRun:
		return m.clearedreport_run
	case deepanalysisresult.EdgeActionGuides:
		return m.clearedaction_guides
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeepAnalysisResultMutation) ClearEdge(name string) error {
	switch name {
	case deepanalysisresult.EdgeReportRun:
		m.ClearReportRun()
		return nil
	}
	return fmt.Errorf("unknown DeepAnalysisResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeepAnalysisResultMutation) ResetEdge(name string) error {
	switch name {
	case deepanalysisresult.EdgeReportRun:
		m.ResetReportRun()
		return nil
	case deepanalysisresult.EdgeActionGuides:
		m.ResetActionGuides()
		return nil
	}
	return fmt.Errorf("unknown DeepAnalysisResult edge %s", name)
}

// DomainReportMutation represents an operation that mutates the DomainReport nodes in the graph.
type DomainReportMutation struct {
	config
	op                Op
	typ               string
	id                *int
	domain_name       *string
	overview          *string
	trends            *string
	score             *int
	addscore          *int
	created_at        *time.Time
	clearedFields     map[string]struct{}
	report_run        *int
	clearedreport_run bool
	articles          map[int]struct{}
	removedarticles   map[int]struct{}
	clearedarticles   bool
	key_events        map[int]struct{}
	removedkey_events map[int]struct{}
	clearedkey_events bool
	done              bool
	oldValue          func(context.Context) (*DomainReport, error)
	predicates        []predicate.DomainReport
}

var _ ent.Mutation = (*DomainReportMutation)(nil)

// domainreportOption allows management of the mutation configuration using functional options.
type domainreportOption func(*DomainReportMutation)

// newDomainReportMutation creates new mutation for the DomainReport entity.
func newDomainReportMutation(c config, op Op, opts ...domainreportOption) *DomainReportMutation {
	m := &DomainReportMutation{
		config:        c,
		op:            op,
		typ:           TypeDomainReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainReportID sets the ID field of the mutation.
func withDomainReportID(id int) domainreportOption {
	return func(m *DomainReportMutation) {
		var (
			err   error
			once  sync.Once
			value *DomainReport
		)
		m.oldValue = func(ctx context.Context) (*DomainReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DomainReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomainReport sets the old DomainReport of the mutation.
func withDomainReport(node *DomainReport) domainreportOption {
	return func(m *DomainReportMutation) {
		m.oldValue = func(context.Context) (*DomainReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DomainReport entities.
func (m *DomainReportMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DomainReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRunID sets the "run_id" field.
func (m *DomainReportMutation) SetRunID(i int) {
	m.report_run = &i
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *DomainReportMutation) RunID() (r int, exists bool) {
	v := m.report_run
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the DomainReport entity.
// If the DomainReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainReportMutation) OldRunID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ClearRunID clears the value of the "run_id" field.
func (m *DomainReportMutation) ClearRunID() {
	m.report_run = nil
	m.clearedFields[domainreport.FieldRunID] = struct{}{}
}

// RunIDCleared returns if the "run_id" field was cleared in this mutation.
func (m *DomainReportMutation) RunIDCleared() bool {
	_, ok := m.clearedFields[domainreport.FieldRunID]
	return ok
}

// ResetRunID resets all changes to the "run_id" field.
func (m *DomainReportMutation) ResetRunID() {
	m.report_run = nil
	delete(m.clearedFields, domainreport.FieldRunID)
}

// SetDomainName sets the "domain_name" field.
func (m *DomainReportMutation) SetDomainName(s string) {
	m.domain_name = &s
}

// DomainName returns the value of the "domain_name" field in the mutation.
func (m *DomainReportMutation) DomainName() (r string, exists bool) {
	v := m.domain_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainName returns the old "domain_name" field's value of the DomainReport entity.
// If the DomainReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainReportMutation) OldDomainName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainName: %w", err)
	}
	return oldValue.DomainName, nil
}

// ResetDomainName resets all changes to the "domain_name" field.
func (m *DomainReportMutation) ResetDomainName() {
	m.domain_name = nil
}

// SetOverview sets the "overview" field.
func (m *DomainReportMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *DomainReportMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the DomainReport entity.
// If the DomainReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainReportMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ClearOverview clears the value of the "overview" field.
func (m *DomainReportMutation) ClearOverview() {
	m.overview = nil
	m.clearedFields[domainreport.FieldOverview] = struct{}{}
}

// OverviewCleared returns if the "overview" field was cleared in this mutation.
func (m *DomainReportMutation) OverviewCleared() bool {
	_, ok := m.clearedFields[domainreport.FieldOverview]
	return ok
}

// ResetOverview resets all changes to the "overview" field.
func (m *DomainReportMutation) ResetOverview() {
	m.overview = nil
	delete(m.clearedFields, domainreport.FieldOverview)
}

// SetTrends sets the "trends" field.
func (m *DomainReportMutation) SetTrends(s string) {
	m.trends = &s
}

// Trends returns the value of the "trends" field in the mutation.
func (m *DomainReportMutation) Trends() (r string, exists bool) {
	v := m.trends
	if v == nil {
		return
	}
	return *v, true
}

// OldTrends returns the old "trends" field's value of the DomainReport entity.
// If the DomainReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainReportMutation) OldTrends(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrends is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrends requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrends: %w", err)
	}
	return oldValue.Trends, nil
}

// ClearTrends clears the value of the "trends" field.
func (m *DomainReportMutation) ClearTrends() {
	m.trends = nil
	m.clearedFields[domainreport.FieldTrends] = struct{}{}
}

// TrendsCleared returns if the "trends" field was cleared in this mutation.
func (m *DomainReportMutation) TrendsCleared() bool {
	_, ok := m.clearedFields[domainreport.FieldTrends]
	return ok
}

// ResetTrends resets all changes to the "trends" field.
func (m *DomainReportMutation) ResetTrends() {
	m.trends = nil
	delete(m.clearedFields, domainreport.FieldTrends)
}

// SetScore sets the "score" field.
func (m *DomainReportMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *DomainReportMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the DomainReport entity.
// If the DomainReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainReportMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *DomainReportMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *DomainReportMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *DomainReportMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[domainreport.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *DomainReportMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[domainreport.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *DomainReportMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, domainreport.FieldScore)
}

// SetCreatedAt sets the "created_at" field.
func (m *DomainReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DomainReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DomainReport entity.
// If the DomainReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DomainReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReportRunID sets the "report_run" edge to the ReportRun entity by id.
func (m *DomainReportMutation) SetReportRunID(id int) {
	m.report_run = &id
}

// ClearReportRun clears the "report_run" edge to the ReportRun entity.
func (m *DomainReportMutation) ClearReportRun() {
	m.clearedreport_run = true
	m.clearedFields[domainreport.FieldRunID] = struct{}{}
}

// ReportRunCleared reports if the "report_run" edge to the ReportRun entity was cleared.
func (m *DomainReportMutation) ReportRunCleared() bool {
	return m.RunIDCleared() || m.clearedreport_run
}

// ReportRunID returns the "report_run" edge ID in the mutation.
func (m *DomainReportMutation) ReportRunID() (id int, exists bool) {
	if m.report_run != nil {
		return *m.report_run, true
	}
	return
}

// ReportRunIDs returns the "report_run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportRunID instead. It exists only for internal usage by the builders.
func (m *DomainReportMutation) ReportRunIDs() (ids []int) {
	if id := m.report_run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportRun resets all changes to the "report_run" edge.
func (m *DomainReportMutation) ResetReportRun() {
	m.report_run = nil
	m.clearedreport_run = false
}

// AddArticleIDs adds the "articles" edge to the Article entity by ids.
func (m *DomainReportMutation) AddArticleIDs(ids ...int) {
	if m.articles == nil {
		m.articles = make(map[int]struct{})
	}
	for i := range ids {
		m.articles[ids[i]] = struct{}{}
	}
}

// ClearArticles clears the "articles" edge to the Article entity.
func (m *DomainReportMutation) ClearArticles() {
	m.clearedarticles = true
}

// ArticlesCleared reports if the "articles" edge to the Article entity was cleared.
func (m *DomainReportMutation) ArticlesCleared() bool {
	return m.clearedarticles
}

// RemoveArticleIDs removes the "articles" edge to the Article entity by IDs.
func (m *DomainReportMutation) RemoveArticleIDs(ids ...int) {
	if m.removedarticles == nil {
		m.removedarticles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.articles, ids[i])
		m.removedarticles[ids[i]] = struct{}{}
	}
}

// RemovedArticles returns the removed IDs of the "articles" edge to the Article entity.
func (m *DomainReportMutation) RemovedArticlesIDs() (ids []int) {
	for id := range m.removedarticles {
		ids = append(ids, id)
	}
	return
}

// ArticlesIDs returns the "articles" edge IDs in the mutation.
func (m *DomainReportMutation) ArticlesIDs() (ids []int) {
	for id := range m.articles {
		ids = append(ids, id)
	}
	return
}

// ResetArticles resets all changes to the "articles" edge.
func (m *DomainReportMutation) ResetArticles() {
	m.articles = nil
	m.clearedarticles = false
	m.removedarticles = nil
}

// AddKeyEventIDs adds the "key_events" edge to the KeyEvent entity by ids.
func (m *DomainReportMutation) AddKeyEventIDs(ids ...int) {
	if m.key_events == nil {
		m.key_events = make(map[int]struct{})
	}
	for i := range ids {
		m.key_events[ids[i]] = struct{}{}
	}
}

// ClearKeyEvents clears the "key_events" edge to the KeyEvent entity.
func (m *DomainReportMutation) ClearKeyEvents() {
	m.clearedkey_events = true
}

// KeyEventsCleared reports if the "key_events" edge to the KeyEvent entity was cleared.
func (m *DomainReportMutation) KeyEventsCleared() bool {
	return m.clearedkey_events
}

// RemoveKeyEventIDs removes the "key_events" edge to the KeyEvent entity by IDs.
func (m *DomainReportMutation) RemoveKeyEventIDs(ids ...int) {
	if m.removedkey_events == nil {
		m.removedkey_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.key_events, ids[i])
		m.removedkey_events[ids[i]] = struct{}{}
	}
}

// RemovedKeyEvents returns the removed IDs of the "key_events" edge to the KeyEvent entity.
func (m *DomainReportMutation) RemovedKeyEventsIDs() (ids []int) {
	for id := range m.removedkey_events {
		ids = append(ids, id)
	}
	return
}

// KeyEventsIDs returns the "key_events" edge IDs in the mutation.
func (m *DomainReportMutation) KeyEventsIDs() (ids []int) {
	for id := range m.key_events {
		ids = append(ids, id)
	}
	return
}

// ResetKeyEvents resets all changes to the "key_events" edge.
func (m *DomainReportMutation) ResetKeyEvents() {
	m.key_events = nil
	m.clearedkey_events = false
	m.removedkey_events = nil
}

// Where appends a list predicates to the DomainReportMutation builder.
func (m *DomainReportMutation) Where(ps ...predicate.DomainReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DomainReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DomainReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DomainReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DomainReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DomainReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DomainReport).
func (m *DomainReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainReportMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.report_run != nil {
		fields = append(fields, domainreport.FieldRunID)
	}
	if m.domain_name != nil {
		fields = append(fields, domainreport.FieldDomainName)
	}
	if m.overview != nil {
		fields = append(fields, domainreport.FieldOverview)
	}
	if m.trends != nil {
		fields = append(fields, domainreport.FieldTrends)
	}
	if m.score != nil {
		fields = append(fields, domainreport.FieldScore)
	}
	if m.created_at != nil {
		fields = append(fields, domainreport.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domainreport.FieldRunID:
		return m.RunID()
	case domainreport.FieldDomainName:
		return m.DomainName()
	case domainreport.FieldOverview:
		return m.Overview()
	case domainreport.FieldTrends:
		return m.Trends()
	case domainreport.FieldScore:
		return m.Score()
	case domainreport.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domainreport.FieldRunID:
		return m.OldRunID(ctx)
	case domainreport.FieldDomainName:
		return m.OldDomainName(ctx)
	case domainreport.FieldOverview:
		return m.OldOverview(ctx)
	case domainreport.FieldTrends:
		return m.OldTrends(ctx)
	case domainreport.FieldScore:
		return m.OldScore(ctx)
	case domainreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DomainReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domainreport.FieldRunID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case domainreport.FieldDomainName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainName(v)
		return nil
	case domainreport.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case domainreport.FieldTrends:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrends(v)
		return nil
	case domainreport.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case domainreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DomainReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainReportMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, domainreport.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case domainreport.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case domainreport.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown DomainReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(domainreport.FieldRunID) {
		fields = append(fields, domainreport.FieldRunID)
	}
	if m.FieldCleared(domainreport.FieldOverview) {
		fields = append(fields, domainreport.FieldOverview)
	}
	if m.FieldCleared(domainreport.FieldTrends) {
		fields = append(fields, domainreport.FieldTrends)
	}
	if m.FieldCleared(domainreport.FieldScore) {
		fields = append(fields, domainreport.FieldScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainReportMutation) ClearField(name string) error {
	switch name {
	case domainreport.FieldRunID:
		m.ClearRunID()
		return nil
	case domainreport.FieldOverview:
		m.ClearOverview()
		return nil
	case domainreport.FieldTrends:
		m.ClearTrends()
		return nil
	case domainreport.FieldScore:
		m.ClearScore()
		return nil
	}
	return fmt.Errorf("unknown DomainReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainReportMutation) ResetField(name string) error {
	switch name {
	case domainreport.FieldRunID:
		m.ResetRunID()
		return nil
	case domainreport.FieldDomainName:
		m.ResetDomainName()
		return nil
	case domainreport.FieldOverview:
		m.ResetOverview()
		return nil
	case domainreport.FieldTrends:
		m.ResetTrends()
		return nil
	case domainreport.FieldScore:
		m.ResetScore()
		return nil
	case domainreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DomainReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.report_run != nil {
		edges = append(edges, domainreport.EdgeReportRun)
	}
	if m.articles != nil {
		edges = append(edges, domainreport.EdgeArticles)
	}
	if m.key_events != nil {
		edges = append(edges, domainreport.EdgeKeyEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domainreport.EdgeReportRun:
		if id := m.report_run; id != nil {
			return []ent.Value{*id}
		}
	case domainreport.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.articles))
		for id := range m.articles {
			ids = append(ids, id)
		}
		return ids
	case domainreport.EdgeKeyEvents:
		ids := make([]ent.Value, 0, len(m.key_events))
		for id := range m.key_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedarticles != nil {
		edges = append(edges, domainreport.EdgeArticles)
	}
	if m.removedkey_events != nil {
		edges = append(edges, domainreport.EdgeKeyEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainReportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domainreport.EdgeArticles:
		ids := make([]ent.Value, 0, len(m.removedarticles))
		for id := range m.removedarticles {
			ids = append(ids, id)
		}
		return ids
	case domainreport.EdgeKeyEvents:
		ids := make([]ent.Value, 0, len(m.removedkey_events))
		for id := range m.removedkey_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreport_run {
		edges = append(edges, domainreport.EdgeReportRun)
	}
	if m.clearedarticles {
		edges = append(edges, domainreport.EdgeArticles)
	}
	if m.clearedkey_events {
		edges = append(edges, domainreport.EdgeKeyEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainReportMutation) EdgeCleared(name string) bool {
	switch name {
	case domainreport.EdgeReportRun:
		return m.clearedreport_run
	case domainreport.EdgeArticles:
		return m.clearedarticles
	case domainreport.EdgeKeyEvents:
		return m.clearedkey_events
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainReportMutation) ClearEdge(name string) error {
	switch name {
	case domainreport.EdgeReportRun:
		m.ClearReportRun()
		return nil
	}
	return fmt.Errorf("unknown DomainReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainReportMutation) ResetEdge(name string) error {
	switch name {
	case domainreport.EdgeReportRun:
		m.ResetReportRun()
		return nil
	case domainreport.EdgeArticles:
		m.ResetArticles()
		return nil
	case domainreport.EdgeKeyEvents:
		m.ResetKeyEvents()
		return nil
	}
	return fmt.Errorf("unknown DomainReport edge %s", name)
}

// KeyEventMutation represents an operation that mutates the KeyEvent nodes in the graph.
type KeyEventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	event_content        *string
	clearedFields        map[string]struct{}
	domain_report        *int
	cleareddomain_report bool
	done                 bool
	oldValue             func(context.Context) (*KeyEvent, error)
	predicates           []predicate.KeyEvent
}

var _ ent.Mutation = (*KeyEventMutation)(nil)

// keyeventOption allows management of the mutation configuration using functional options.
type keyeventOption func(*KeyEventMutation)

// newKeyEventMutation creates new mutation for the KeyEvent entity.
func newKeyEventMutation(c config, op Op, opts ...keyeventOption) *KeyEventMutation {
	m := &KeyEventMutation{
		config:        c,
		op:            op,
		typ:           TypeKeyEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeyEventID sets the ID field of the mutation.
func withKeyEventID(id int) keyeventOption {
	return func(m *KeyEventMutation) {
		var (
			err   error
			once  sync.Once
			value *KeyEvent
		)
		m.oldValue = func(ctx context.Context) (*KeyEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeyEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeyEvent sets the old KeyEvent of the mutation.
func withKeyEvent(node *KeyEvent) keyeventOption {
	return func(m *KeyEventMutation) {
		m.oldValue = func(context.Context) (*KeyEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeyEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeyEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeyEvent entities.
func (m *KeyEventMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeyEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeyEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeyEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDomainReportID sets the "domain_report_id" field.
func (m *KeyEventMutation) SetDomainReportID(i int) {
	m.domain_report = &i
}

// DomainReportID returns the value of the "domain_report_id" field in the mutation.
func (m *KeyEventMutation) DomainReportID() (r int, exists bool) {
	v := m.domain_report
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainReportID returns the old "domain_report_id" field's value of the KeyEvent entity.
// If the KeyEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeyEventMutation) OldDomainReportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainReportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainReportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainReportID: %w", err)
	}
	return oldValue.DomainReportID, nil
}

// ClearDomainReportID clears the value of the "domain_report_id" field.
func (m *KeyEventMutation) ClearDomainReportID() {
	m.domain_report = nil
	m.clearedFields[keyevent.FieldDomainReportID] = struct{}{}
}

// DomainReportIDCleared returns if the "domain_report_id" field was cleared in this mutation.
func (m *KeyEventMutation) DomainReportIDCleared() bool {
	_, ok := m.clearedFields[keyevent.FieldDomainReportID]
	return ok
}

// ResetDomainReportID resets all changes to the "domain_report_id" field.
func (m *KeyEventMutation) ResetDomainReportID() {
	m.domain_report = nil
	delete(m.clearedFields, keyevent.FieldDomainReportID)
}

// SetEventContent sets the "event_content" field.
func (m *KeyEventMutation) SetEventContent(s string) {
	m.event_content = &s
}

// EventContent returns the value of the "event_content" field in the mutation.
func (m *KeyEventMutation) EventContent() (r string, exists bool) {
	v := m.event_content
	if v == nil {
		return
	}
	return *v, true
}

// OldEventContent returns the old "event_content" field's value of the KeyEvent entity.
// If the KeyEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeyEventMutation) OldEventContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventContent: %w", err)
	}
	return oldValue.EventContent, nil
}

// ClearEventContent clears the value of the "event_content" field.
func (m *KeyEventMutation) ClearEventContent() {
	m.event_content = nil
	m.clearedFields[keyevent.FieldEventContent] = struct{}{}
}

// EventContentCleared returns if the "event_content" field was cleared in this mutation.
func (m *KeyEventMutation) EventContentCleared() bool {
	_, ok := m.clearedFields[keyevent.FieldEventContent]
	return ok
}

// ResetEventContent resets all changes to the "event_content" field.
func (m *KeyEventMutation) ResetEventContent() {
	m.event_content = nil
	delete(m.clearedFields, keyevent.FieldEventContent)
}

// ClearDomainReport clears the "domain_report" edge to the DomainReport entity.
func (m *KeyEventMutation) ClearDomainReport() {
	m.cleareddomain_report = true
	m.clearedFields[keyevent.FieldDomainReportID] = struct{}{}
}

// DomainReportCleared reports if the "domain_report" edge to the DomainReport entity was cleared.
func (m *KeyEventMutation) DomainReportCleared() bool {
	return m.DomainReportIDCleared() || m.cleareddomain_report
}

// DomainReportIDs returns the "domain_report" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainReportID instead. It exists only for internal usage by the builders.
func (m *KeyEventMutation) DomainReportIDs() (ids []int) {
	if id := m.domain_report; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomainReport resets all changes to the "domain_report" edge.
func (m *KeyEventMutation) ResetDomainReport() {
	m.domain_report = nil
	m.cleareddomain_report = false
}

// Where appends a list predicates to the KeyEventMutation builder.
func (m *KeyEventMutation) Where(ps ...predicate.KeyEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeyEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeyEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KeyEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeyEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeyEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KeyEvent).
func (m *KeyEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeyEventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.domain_report != nil {
		fields = append(fields, keyevent.FieldDomainReportID)
	}
	if m.event_content != nil {
		fields = append(fields, keyevent.FieldEventContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeyEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case keyevent.FieldDomainReportID:
		return m.DomainReportID()
	case keyevent.FieldEventContent:
		return m.EventContent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeyEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case keyevent.FieldDomainReportID:
		return m.OldDomainReportID(ctx)
	case keyevent.FieldEventContent:
		return m.OldEventContent(ctx)
	}
	return nil, fmt.Errorf("unknown KeyEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeyEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case keyevent.FieldDomainReportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainReportID(v)
		return nil
	case keyevent.FieldEventContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventContent(v)
		return nil
	}
	return fmt.Errorf("unknown KeyEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeyEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeyEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeyEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeyEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeyEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(keyevent.FieldDomainReportID) {
		fields = append(fields, keyevent.FieldDomainReportID)
	}
	if m.FieldCleared(keyevent.FieldEventContent) {
		fields = append(fields, keyevent.FieldEventContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeyEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeyEventMutation) ClearField(name string) error {
	switch name {
	case keyevent.FieldDomainReportID:
		m.ClearDomainReportID()
		return nil
	case keyevent.FieldEventContent:
		m.ClearEventContent()
		return nil
	}
	return fmt.Errorf("unknown KeyEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeyEventMutation) ResetField(name string) error {
	switch name {
	case keyevent.FieldDomainReportID:
		m.ResetDomainReportID()
		return nil
	case keyevent.FieldEventContent:
		m.ResetEventContent()
		return nil
	}
	return fmt.Errorf("unknown KeyEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeyEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.domain_report != nil {
		edges = append(edges, keyevent.EdgeDomainReport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeyEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case keyevent.EdgeDomainReport:
		if id := m.domain_report; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeyEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeyEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeyEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddomain_report {
		edges = append(edges, keyevent.EdgeDomainReport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeyEventMutation) EdgeCleared(name string) bool {
	switch name {
	case keyevent.EdgeDomainReport:
		return m.cleareddomain_report
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeyEventMutation) ClearEdge(name string) error {
	switch name {
	case keyevent.EdgeDomainReport:
		m.ClearDomainReport()
		return nil
	}
	return fmt.Errorf("unknown KeyEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeyEventMutation) ResetEdge(name string) error {
	switch name {
	case keyevent.EdgeDomainReport:
		m.ResetDomainReport()
		return nil
	}
	return fmt.Errorf("unknown KeyEvent edge %s", name)
}

// ReportRunMutation represents an operation that mutates the ReportRun nodes in the graph.
type ReportRunMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	clearedFields                map[string]struct{}
	domain_reports               map[int]struct{}
	removeddomain_reports        map[int]struct{}
	cleareddomain_reports        bool
	deep_analysis_results        map[int]struct{}
	removeddeep_analysis_results map[int]struct{}
	cleareddeep_analysis_results bool
	done                         bool
	oldValue                     func(context.Context) (*ReportRun, error)
	predicates                   []predicate.ReportRun
}

var _ ent.Mutation = (*ReportRunMutation)(nil)

// reportrunOption allows management of the mutation configuration using functional options.
type reportrunOption func(*ReportRunMutation)

// newReportRunMutation creates new mutation for the ReportRun entity.
func newReportRunMutation(c config, op Op, opts ...reportrunOption) *ReportRunMutation {
	m := &ReportRunMutation{
		config:        c,
		op:            op,
		typ:           TypeReportRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportRunID sets the ID field of the mutation.
func withReportRunID(id int) reportrunOption {
	return func(m *ReportRunMutation) {
		var (
			err   error
			once  sync.Once
			value *ReportRun
		)
		m.oldValue = func(ctx context.Context) (*ReportRun, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReportRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReportRun sets the old ReportRun of the mutation.
func withReportRun(node *ReportRun) reportrunOption {
	return func(m *ReportRunMutation) {
		m.oldValue = func(context.Context) (*ReportRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReportRun entities.
func (m *ReportRunMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportRunMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportRunMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReportRun.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReportRunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReportRunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReportRun entity.
// If the ReportRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportRunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReportRunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddDomainReportIDs adds the "domain_reports" edge to the DomainReport entity by ids.
func (m *ReportRunMutation) AddDomainReportIDs(ids ...int) {
	if m.domain_reports == nil {
		m.domain_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.domain_reports[ids[i]] = struct{}{}
	}
}

// ClearDomainReports clears the "domain_reports" edge to the DomainReport entity.
func (m *ReportRunMutation) ClearDomainReports() {
	m.cleareddomain_reports = true
}

// DomainReportsCleared reports if the "domain_reports" edge to the DomainReport entity was cleared.
func (m *ReportRunMutation) DomainReportsCleared() bool {
	return m.cleareddomain_reports
}

// RemoveDomainReportIDs removes the "domain_reports" edge to the DomainReport entity by IDs.
func (m *ReportRunMutation) RemoveDomainReportIDs(ids ...int) {
	if m.removeddomain_reports == nil {
		m.removeddomain_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain_reports, ids[i])
		m.removeddomain_reports[ids[i]] = struct{}{}
	}
}

// RemovedDomainReports returns the removed IDs of the "domain_reports" edge to the DomainReport entity.
func (m *ReportRunMutation) RemovedDomainReportsIDs() (ids []int) {
	for id := range m.removeddomain_reports {
		ids = append(ids, id)
	}
	return
}

// DomainReportsIDs returns the "domain_reports" edge IDs in the mutation.
func (m *ReportRunMutation) DomainReportsIDs() (ids []int) {
	for id := range m.domain_reports {
		ids = append(ids, id)
	}
	return
}

// ResetDomainReports resets all changes to the "domain_reports" edge.
func (m *ReportRunMutation) ResetDomainReports() {
	m.domain_reports = nil
	m.cleareddomain_reports = false
	m.removeddomain_reports = nil
}

// AddDeepAnalysisResultIDs adds the "deep_analysis_results" edge to the DeepAnalysisResult entity by ids.
func (m *ReportRunMutation) AddDeepAnalysisResultIDs(ids ...int) {
	if m.deep_analysis_results == nil {
		m.deep_analysis_results = make(map[int]struct{})
	}
	for i := range ids {
		m.deep_analysis_results[ids[i]] = struct{}{}
	}
}

// ClearDeepAnalysisResults clears the "deep_analysis_results" edge to the DeepAnalysisResult entity.
func (m *ReportRunMutation) ClearDeepAnalysisResults() {
	m.cleareddeep_analysis_results = true
}

// DeepAnalysisResultsCleared reports if the "deep_analysis_results" edge to the DeepAnalysisResult entity was cleared.
func (m *ReportRunMutation) DeepAnalysisResultsCleared() bool {
	return m.cleareddeep_analysis_results
}

// RemoveDeepAnalysisResultIDs removes the "deep_analysis_results" edge to the DeepAnalysisResult entity by IDs.
func (m *ReportRunMutation) RemoveDeepAnalysisResultIDs(ids ...int) {
	if m.removeddeep_analysis_results == nil {
		m.removeddeep_analysis_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deep_analysis_results, ids[i])
		m.removeddeep_analysis_results[ids[i]] = struct{}{}
	}
}

// RemovedDeepAnalysisResults returns the removed IDs of the "deep_analysis_results" edge to the DeepAnalysisResult entity.
func (m *ReportRunMutation) RemovedDeepAnalysisResultsIDs() (ids []int) {
	for id := range m.removeddeep_analysis_results {
		ids = append(ids, id)
	}
	return
}

// DeepAnalysisResultsIDs returns the "deep_analysis_results" edge IDs in the mutation.
func (m *ReportRunMutation) DeepAnalysisResultsIDs() (ids []int) {
	for id := range m.deep_analysis_results {
		ids = append(ids, id)
	}
	return
}

// ResetDeepAnalysisResults resets all changes to the "deep_analysis_results" edge.
func (m *ReportRunMutation) ResetDeepAnalysisResults() {
	m.deep_analysis_results = nil
	m.cleareddeep_analysis_results = false
	m.removeddeep_analysis_results = nil
}

// Where appends a list predicates to the ReportRunMutation builder.
func (m *ReportRunMutation) Where(ps ...predicate.ReportRun) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportRunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportRunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReportRun, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportRunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportRunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReportRun).
func (m *ReportRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportRunMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, reportrun.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reportrun.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reportrun.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ReportRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reportrun.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ReportRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportRunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportRunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReportRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportRunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportRunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReportRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportRunMutation) ResetField(name string) error {
	switch name {
	case reportrun.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ReportRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.domain_reports != nil {
		edges = append(edges, reportrun.EdgeDomainReports)
	}
	if m.deep_analysis_results != nil {
		edges = append(edges, reportrun.EdgeDeepAnalysisResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reportrun.EdgeDomainReports:
		ids := make([]ent.Value, 0, len(m.domain_reports))
		for id := range m.domain_reports {
			ids = append(ids, id)
		}
		return ids
	case reportrun.EdgeDeepAnalysisResults:
		ids := make([]ent.Value, 0, len(m.deep_analysis_results))
		for id := range m.deep_analysis_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddomain_reports != nil {
		edges = append(edges, reportrun.EdgeDomainReports)
	}
	if m.removeddeep_analysis_results != nil {
		edges = append(edges, reportrun.EdgeDeepAnalysisResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportRunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reportrun.EdgeDomainReports:
		ids := make([]ent.Value, 0, len(m.removeddomain_reports))
		for id := range m.removeddomain_reports {
			ids = append(ids, id)
		}
		return ids
	case reportrun.EdgeDeepAnalysisResults:
		ids := make([]ent.Value, 0, len(m.removeddeep_analysis_results))
		for id := range m.removeddeep_analysis_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddomain_reports {
		edges = append(edges, reportrun.EdgeDomainReports)
	}
	if m.cleareddeep_analysis_results {
		edges = append(edges, reportrun.EdgeDeepAnalysisResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportRunMutation) EdgeCleared(name string) bool {
	switch name {
	case reportrun.EdgeDomainReports:
		return m.cleareddomain_reports
	case reportrun.EdgeDeepAnalysisResults:
		return m.cleareddeep_analysis_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportRunMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ReportRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportRunMutation) ResetEdge(name string) error {
	switch name {
	case reportrun.EdgeDomainReports:
		m.ResetDomainReports()
		return nil
	case reportrun.EdgeDeepAnalysisResults:
		m.ResetDeepAnalysisResults()
		return nil
	}
	return fmt.Errorf("unknown ReportRun edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password_hash *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
